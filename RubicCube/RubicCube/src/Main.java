/* autogenerated by Processing revision 1292 on 2023-03-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import java.util.Iterator;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import algorithm.*;
import cube.*;
import settings.*;

public class Main extends PApplet {



    PeasyCam cam;
    Settings setting;
    AlgorithmCollection algorithm;
    Move move;
    RubiksCubeLogic cube;
    boolean isTured;
    boolean animating = true;

    public void setup() {
        /* size commented out by preprocessor */;
        setting = new Settings();
        cam = new PeasyCam(this, setting.cameraZoomIn);
        algorithm = new AlgorithmCollection(this);
        cube = new RubiksCubeLogic(this);
        move = new Move(this,0,0,0,0, cube.getCube());

    }

    public void draw () {
        move.update();
        background(setting.backgroundColor);
        cube.getCube().drawCube(move);
        if(cube.moveList != "") {
            if(frameCount % 15 == 0) {
                isTured = true;
                DoStuff(cube.moveList.charAt(0));
                cube.moveList=cube.moveList.substring(1, cube.moveList.length());
            }
        } else if(cube.solving) {
            cube.solve();
        }
    }


    public void keyPressed () {
        if (!move.isAnimate()) {
            if(key == 'm' || key == 'M' || key == 'w' || key == 'W') {
                println("if you want the ai solve this move is illegal");
                DoStuff(key);
            } else {
                DoStuff(key);
            }
        }
    }
    public void DoStuff(char keys) {
        if (!move.isAnimate()) {
            switch (keys) {
                case ' ' :
                    cube.shuffleCube();
                    break;
                case 's' :
                    //start solving the cube
                    cube.solving = true;
                    break;
                case 'y' :
                    cube.doPerm(algorithm.getAlgorithm("yperm"));
                    break;
                case 't' :
                    cube.doPerm(algorithm.getAlgorithm("tperm"));
                    break;
                case 'j' :
                    cube.doPerm(algorithm.getAlgorithm("jperm"));
                    break;
                case 'p' :
                    cube.doPerm(algorithm.getAlgorithm("lperm"));
                    break;
                case 'm' :
                    move = new Move(this,2, 0, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'M' :
                    move = new Move(this,2, 0, 0, -1, cube.getCube());
                    move.start();
                    break;
                case 'w' :
                    move = new Move(this,0, -2, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'W' :
                    move = new Move(this,0, 2, 0, -1, cube.getCube());
                    move.start();
                    break;
                case 'l' :
                    move = new Move(this,-1, 0, 0, -1, cube.getCube());
                    move.start();
                    break;
                case 'L' :
                    move = new Move(this,-1, 0, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'r' :
                    move = new Move(this,1, 0, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'R' :
                    move = new Move(this,1, 0, 0, -1, cube.getCube());
                    move.start();
                    break;
                case 'f' :
                    move = new Move(this,0, 0, 1, 1, cube.getCube());
                    move.start();
                    break;
                case 'F' :
                    move = new Move(this,0, 0, 1, -1, cube.getCube());
                    move.start();
                    break;
                case 'b' :
                    move = new Move(this,0, 0, -1, -1, cube.getCube());
                    move.start();
                    break;
                case 'B' :
                    move = new Move(this,0, 0, -1, 1, cube.getCube());
                    move.start();
                    break;
                case 'u' :
                    move = new Move(this,0, -1, 0, -1, cube.getCube());
                    move.start();
                    break;
                case 'U' :
                    move = new Move(this,0, -1, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'd' :
                    move = new Move(this,0, 1, 0, 1, cube.getCube());
                    move.start();
                    break;
                case 'D' :
                    move = new Move(this,0, 1, 0, -1, cube.getCube());
                    move.start();
                    break;
            }
        }
    }



    public class RubiksCubeLogic  {
        private PApplet sketch;
        private String moveList = "";
        boolean solving = false;
        private Cube cube;
        private AlgorithmCollection algorithmCollection;
        OldPochman op;
        int animationTimer = 0;
        int moveCounter = 0;
        private boolean edgesSolved = false;
        boolean isParityNeeded = true;

        public RubiksCubeLogic(PApplet sketch) {
            this.sketch = sketch;
            this.algorithmCollection = new AlgorithmCollection(sketch);
            this.cube = new Cube(this.sketch);
            this.op = new OldPochman(this.sketch,this.cube, this.moveList);
        }

        public Cube getCube() {
            return this.cube;
        }

        public void shuffleCube() {
            int rand = round(random(10, 20));
            println("Shuffle is " + rand + " moves long.");
            char[] moves = {'l','L','r','R','u','U','d','D','f','F','b','B'};
            for (int i = 0; i < rand; i++) {
                int random = round(random(0, 11));
                moveList += moves[random];
            }
        }

        public void doPerm(Algorithm alg) {
            for (int i = 0; i < alg.getMoves().length; i++) {
                this.moveList += alg.getMoves()[i];
            }
        }

        private String reverseAlgorithm(String[] inputs) {
            String[] strings = new String[inputs.length];
            for (int i = 0; i < inputs.length; ++i) {
                strings[i] = inputs[i];
            }
            for (int i = 0; i < strings.length / 2; i++) {
                String temp = strings[i];
                strings[i] = strings[strings.length - 1 - i];
                strings[strings.length - 1 - i] = temp;
            }
            StringBuilder sb = new StringBuilder();
            for (String s : strings) {
                char c = s.charAt(0);
                if (Character.isUpperCase(c)) {
                    sb.append(Character.toLowerCase(c));
                } else if (Character.isLowerCase(c)) {
                    sb.append(Character.toUpperCase(c));
                } else {
                    sb.append(c);
                }
            }
            return sb.toString();
        }

        public void solve() {
            this.solving = true;
            if (this.edgesSolved) {
                if (moveCounter % 2 ==  1 && isParityNeeded) {
                    this.moveList += "ruRFruuRuuRfruruuRU";
                    isParityNeeded = false;
                }
                int id = this.op.lookForCornerBuffer();
                if (id != 3 && id != 5 && id != 0) {
                    SolveOnePiece(id);
                    //this.solving = false;  //minden lepes utan megallas
                } else {
                    ArrayList<Cubie> notInPosition = this.cube.checkIfAllCornersAreSolved();
                    if (notInPosition.size() > 0) {
                        this.animationTimer++;
                    } else {
                        this.animationTimer = 0;
                        println("corners are done, it took " + Integer.toString(moveCounter) + " moves.");
                        this.solving = false;
                    }
                    if (this.animationTimer >= 100) {
                        this.animationTimer = 0;
                        println("corners are not done, breaking the plugging.");
                        boolean chekForFlippedBuffer = breakPlugging(notInPosition.get(0));
                        if (!chekForFlippedBuffer) {
                            breakPlugging(notInPosition.get(1));
                        }

                    }
                }
            } else {
                int id = this.op.lookForEdgeBuffer();
                if (id != 117 && id != 118) {
                    SolveOnePiece(id);
                    //this.solving = false;  //minden lepes utan megallas
                } else {
                    ArrayList<Cubie> notInPosition = this.cube.checkIfAllEdgesAreSolved();
                    if (notInPosition.size() > 0) {
                        this.animationTimer++;
                    } else {
                        println("edges are done, it took " + Integer.toString(moveCounter) + " moves.");
                        this.edgesSolved = true;
                        this.animationTimer = 0;
                    }
                    if (this.animationTimer >= 100) {
                        println("edges are not done, breaking the plugging.");
                        boolean chekForFlippedBuffer = breakPlugging(notInPosition.get(0));
                        if (!chekForFlippedBuffer) {
                            breakPlugging(notInPosition.get(1));
                        }
                        this.animationTimer = 0;
                    }
                }
            }
        }

        public boolean breakPlugging(Cubie cubie) {
            for (Face face : cubie.getFaces()) {
                if (this.op.isItInAlgorithms(Integer.toString(face.getId()))) {
                    // this is needed becouse the buffer can get stuck
                    if (face.getId() == 117 || face.getId() == 118 || face.getId() == 3 || face.getId() == 5 || face.getId() == 0) {
                        return false;
                    }
                    SolveOnePiece(face.getId());
                    return true;
                }
            }
            return false;
        }

        public void SolveOnePiece(int id) {
            this.moveCounter++;
            OldPochmanAlgorithm algo = this.op.moveToTarget(id);
            this.moveList += join(algo.getSetup(),"");
            this.moveList += join(algorithmCollection.getAlgorithm(algo.getAlgorithmName()).getMoves(), "");
            try {
                Thread.sleep(100);
            } catch(Exception e) {
                println(e);
            }
            String reversedMoves = reverseAlgorithm(algo.getSetup());
            logMove(Integer.toString(id), join(algo.getSetup(),""), algorithmCollection.getAlgorithm(algo.getAlgorithmName()).getName(), reversedMoves);
            this.moveList += reversedMoves;
        }

        private void logMove(String id, String setup, String algorithm, String redo) {
            println("buffer id: " + id + " || setup: " + setup + " || algorithm: " + algorithm + " || redo setup: " + redo);
        }

    }

    public void settings() { size(600, 600, P3D); }

    static public void main(String[] passedArgs) {
        String[] appletArgs = new String[] { "Main" };
        if (passedArgs != null) {
            PApplet.main(concat(appletArgs, passedArgs));
        } else {
            PApplet.main(appletArgs);
        }
    }
}
