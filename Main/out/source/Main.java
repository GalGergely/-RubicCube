/* autogenerated by Processing revision 1289 on 2023-03-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import java.util.Iterator;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Main extends PApplet {



PeasyCam cam;
Settings setting;
AlgorithmCollection algorithm;
Move move;
RubiksCubeLogic cube;
boolean isTured;
boolean animating = true;

public void setup() {
/* size commented out by preprocessor */;
setting = new Settings();
cam = new PeasyCam(this, setting.cameraZoomIn);
algorithm = new AlgorithmCollection();
cube = new RubiksCubeLogic();
move = new Move(0,0,0,0, cube.getCube());

}

public void draw () {
  move.update();
  background(setting.backgroundColor);
  cube.getCube().drawCube(move);
  if(cube.moveList != "") {
    if(frameCount % 15 == 0) {
      isTured = true;
      DoStuff(cube.moveList.charAt(0));
      cube.moveList=cube.moveList.substring(1, cube.moveList.length());
    }
  } else if(cube.solving) {
    cube.solve();
  }
}
public class Algorithm {
    private String name;
    private String[] moves;

    public Algorithm(String name, String[] moves) {
        this.name = name;
        this.moves = moves;
    }

    public String getName() {
        return name;
    }

    public String[] getMoves() {
        return moves;
    }
}


public class AlgorithmCollection {
    private ArrayList<Algorithm> algorithms = new ArrayList<Algorithm>();
    private JSONObject json;
    
    public AlgorithmCollection () {
        json = loadJSONObject("algorithms.json");
        // Iterate through the keys of the JSON object
        for (String key : (String[]) json.keys().toArray(new String[json.size()])) {
            // Get the JSON array associated with the key
            JSONArray array = json.getJSONArray(key);

            // Convert the JSON array to a String array
            String[] moves = new String[array.size()];
            for (int i = 0; i < array.size(); i++) {
                moves[i] = array.getString(i);
            }

            // Create a new Algorithm object and add it to the list
            algorithms.add(new Algorithm(key, moves));
        }
    }
    
    public Algorithm getAlgorithm(String name) {
      for (Algorithm algorithm : algorithms) {
        if(name.equals(algorithm.getName())) {
          return algorithm;
        }
      }
      String[] bad_return  = {};
      Algorithm al = new Algorithm("does not exist", bad_return);
      return al;
    }

    public void printAlgorithms() {
        // Iterate through the algorithms list and print each algorithm
        for (Algorithm algorithm : algorithms) {
            println(algorithm.getName() + ": " + join(algorithm.getMoves(), " "));
        }
    }

    public void add(String name, String[] moves) {
        // Create a new Algorithm object and add it to the list
        algorithms.add(new Algorithm(name, moves));

        // Create a new JSON array and add the moves to it
        JSONArray array = new JSONArray();
        for (String move : moves) {
            array.append(move);
        }

        // Add the new key-value pair to the JSON object and save it to the file
        json.setJSONArray(name, array);
        saveJSONObject(json, "algorithms.json");
    }

    public void delete(String name) {
        // Remove the Algorithm object with the given name from the list
        for (int i = 0; i < algorithms.size(); i++) {
            if (algorithms.get(i).getName().equals(name)) {
                algorithms.remove(i);
                break;
            }
        }

        // Remove the key-value pair with the given name from the JSON object and save it to the file
        json.remove(name);
        saveJSONObject(json, "algorithms.json");
    }
}
class Cube {
  Settings setting = new Settings();
  int dimension = setting.dimension;
  public Cubie[] data = new Cubie[dimension*dimension*dimension];
  int facecounter=0;
  int[] edges = {1,3,5,7,9,11,15,17,19,21,23,25};
  int[] corners = {0, 2, 6, 8, 18, 20, 24, 26};

  Cube() {
    int index = 0;
    for (int x=-1; x<=1; x++) {
      for (int y=-1; y<=1; y++) {
        for (int z=-1; z<=1; z++) {
          PMatrix3D matrix = new PMatrix3D();
          matrix.translate(x, y, z);
          data[index] = new Cubie(matrix, x, y, z, facecounter);
          facecounter+=6;
          index++;
        }
      }
    }
  }

  public ArrayList<Cubie> checkIfAllEdgesAreSolved() {
    ArrayList<Cubie> notInPosition = new ArrayList<Cubie>();
    for (int edge : this.edges) {
      if(data[edge].x == data[edge].solvedPosition.x && data[edge].y == data[edge].solvedPosition.y && data[edge].z == data[edge].solvedPosition.z) {
        if (data[edge].faces[0].facing == Facing.BACK && data[edge].faces[2].facing == Facing.DOWN) {
          //its in his position
        } else {
          notInPosition.add(data[edge]);
        }
      } else {
        notInPosition.add(data[edge]);
      }
    }
    return notInPosition;
  }

  public ArrayList<Cubie> checkIfAllCornersAreSolved() {
    ArrayList<Cubie> notInPosition = new ArrayList<Cubie>();
    for (int corner : this.corners) {
      if(data[corner].x == data[corner].solvedPosition.x && data[corner].y == data[corner].solvedPosition.y && data[corner].z == data[corner].solvedPosition.z) {
        if (data[corner].faces[0].facing == Facing.BACK && data[corner].faces[2].facing == Facing.DOWN) {
          //its in his position
        } else {
          notInPosition.add(data[corner]);
        }
      } else {
        notInPosition.add(data[corner]);
      }
    }
    return notInPosition;
  }

  public void turnX(int index, int dir) {
    for (int i=0; i<data.length; i++) {
      if (data[i].x == index) {
        PMatrix2D matrix = new PMatrix2D();
        matrix.rotate(dir*HALF_PI);
        matrix.translate(data[i].y, data[i].z);
        data[i].update(data[i].x, round(matrix.m02), round(matrix.m12));
        data[i].turnFacesX(dir);
      }
    }
  }
  public void turnY(int index, int dir) {
    for (int i=0; i<data.length; i++) {
      if (data[i].y == index) {
        PMatrix2D matrix = new PMatrix2D();
        matrix.rotate(-dir*HALF_PI);
        matrix.translate(data[i].x, data[i].z);
        data[i].update(round(matrix.m02), data[i].y, round(matrix.m12));
        data[i].turnFacesY(-dir);
      }
    }
  }

  public void turnZ(int index, int dir) {
    for (int i=0; i<data.length; i++) {
      if (data[i].z == index) {
        PMatrix2D matrix = new PMatrix2D();
        matrix.rotate(dir*HALF_PI);
        matrix.translate(data[i].x, data[i].y);
        data[i].update(round(matrix.m02), round(matrix.m12), data[i].z);
        data[i].turnFacesZ(dir);
      }
    }
  }

  public void drawCube(Move move) {
    scale(50);
    for (int i=0; i<data.length; i++) {
      push();
      if (abs(data[i].z)==1 && data[i].z == move.z) {
        rotateZ(move.angle);
      } else if (abs(data[i].x)==1 && data[i].x == move.x) {
        rotateX(move.angle);
      } else if (abs(data[i].y)==1 && data[i].y == move.y) {
        rotateY(move.angle);
      } else if (abs(data[i].z)==0 && data[i].z == abs(move.z)-2) {
        rotateZ(move.angle);
      } else if (abs(data[i].y)==0 && data[i].y == abs(move.y)-2) {
        rotateY(move.angle);
      } else if (abs(data[i].x)==0 && data[i].x == abs(move.x)-2) {
        rotateX(move.angle);
      }
      data[i].show();
      pop();
    }
  }
}
class Cubie {
  Settings setting = new Settings();
  PMatrix3D matrix;
  int x;
  int y;
  int z;
  Face[] faces = new Face[6];

  PVector solvedPosition;


  Cubie(PMatrix3D m, int x, int y, int z, int facecounter) {
      solvedPosition = new PVector(x,y,z);
      this.matrix=m;
      this.x=x;
      this.y=y;
      this.z=z;
      faces[0] = new Face(new PVector(0,0,-1), setting.blue, facecounter++, Facing.BACK);
      faces[1] = new Face(new PVector(0,0,1), setting.green, facecounter++, Facing.FRONT);
      faces[2] = new Face(new PVector(0,1,0), setting.white, facecounter++, Facing.DOWN);
      faces[3] = new Face(new PVector(0,-1,0), setting.yellow, facecounter++, Facing.UP);
      faces[4] = new Face(new PVector(1,0,0), setting.orange ,facecounter++, Facing.RIGHT);
      faces[5] = new Face(new PVector(-1,0,0), setting.red ,facecounter++, Facing.LEFT);

  }

  public void turnFacesX(int dir) {
    for(int i=0; i<faces.length; i++) {
      faces[i].rotateFacingX(dir);
      faces[i].turnX(dir*HALF_PI);
    }
  }
    public void turnFacesY(int dir) {
    for(int i=0; i<faces.length; i++) {
      faces[i].rotateFacingY(dir);
      faces[i].turnY(dir*HALF_PI);
    }
  }
    public void turnFacesZ(int dir) {
    for(int i=0; i<faces.length; i++) {
      faces[i].rotateFacingZ(dir);
      faces[i].turnZ(dir*HALF_PI);
    }
  }
   public void update(int x, int y, int z) {
     matrix.reset();
     matrix.translate(x,y,z);
      this.x=x;
      this.y=y;
      this.z=z;
   }

   public void show(){
   noFill();
   stroke(setting.strokeColor);
   strokeWeight(setting.strokeWeight);
   pushMatrix();
   applyMatrix(matrix);
   //if(this.x == -1 && this.y == -1 && this.z == -1) {
   //} else {
   for(int i=0; i<faces.length; i++) {
     faces[i].show();
   //}
   }
   popMatrix();
  }

  public String toString() {
    return "current:" + "x;" + x + " y:" + y + " :z" + z + "    solved: " + "x;" + solvedPosition.x + " y:" + solvedPosition.y + " :z" + solvedPosition.z+"\n";
  }
  public String toStringWithId() {
    String returnString = "current:" + "x;" + x + " y:" + y + " :z" + z + " ids:";
    for(Face face : faces) {
        returnString += face.id;
    }
    return returnString;
  }
}
class Face {
  PVector normal;
  int c;
  int id;
  IdDisplay display;
  Facing facing;

  Face(PVector normal, int c, int id, Facing facing) {
    this.normal = normal;
    this.c=c;
    this.id = id;
    this.facing = facing;
    this.display = new IdDisplay(this.id);
  }
    public void turnX(float angle) {
    PVector v = new PVector();
    v.y = round(normal.y * cos(angle) - normal.z * sin(angle));
    v.z = round(normal.y * sin(angle) - normal.z * cos(angle));
    v.x = round(normal.x);
    normal = v;
  }
  public void turnY(float angle) {
    PVector v = new PVector();
    v.x = round(normal.x * cos(angle) - normal.z * sin(angle));
    v.z = round(normal.x * sin(angle) - normal.z * cos(angle));
    v.y = round(normal.y);
    normal = v;
  }
  public void turnZ(float angle) {
    PVector v = new PVector();
    v.x = round(normal.x * cos(angle) - normal.y * sin(angle));
    v.y = round(normal.x * sin(angle) - normal.y * cos(angle));
    v.z = round(normal.z);
    normal = v;
  }
  public void rotateFacingX(int dir) {
    if(dir < 0) {
      if(this.facing==Facing.UP){
        this.facing=Facing.FRONT;
      } else if (this.facing==Facing.FRONT) {
        this.facing=Facing.DOWN;
      } else if (this.facing==Facing.DOWN) {
        this.facing=Facing.BACK;
      } else if (this.facing==Facing.BACK) {
        this.facing=Facing.UP;
      }
    } else {
      if(this.facing==Facing.UP){
        this.facing=Facing.BACK;
      } else if (this.facing==Facing.BACK) {
        this.facing=Facing.DOWN;
      } else if (this.facing==Facing.DOWN) {
        this.facing=Facing.FRONT;
      } else if (this.facing==Facing.FRONT) {
        this.facing=Facing.UP;
      }
    }
  }

  public void rotateFacingY(int dir) {
    if(dir < 0) {
      if(this.facing==Facing.FRONT){
        this.facing=Facing.RIGHT;
      } else if (this.facing==Facing.RIGHT) {
        this.facing=Facing.BACK;
      } else if (this.facing==Facing.BACK) {
        this.facing=Facing.LEFT;
      } else if (this.facing==Facing.LEFT) {
        this.facing=Facing.FRONT;
      }
    } else {
      if(this.facing==Facing.FRONT){
        this.facing=Facing.LEFT;
      } else if (this.facing==Facing.LEFT) {
        this.facing=Facing.BACK;
      } else if (this.facing==Facing.BACK) {
        this.facing=Facing.RIGHT;
      } else if (this.facing==Facing.RIGHT) {
        this.facing=Facing.FRONT;
      }
    }
  }

  public void rotateFacingZ(int dir) {
    if(dir < 0) {
      if(this.facing==Facing.UP){
        this.facing=Facing.LEFT;
      } else if (this.facing==Facing.LEFT) {
        this.facing=Facing.DOWN;
      } else if (this.facing==Facing.DOWN) {
        this.facing=Facing.RIGHT;
      } else if (this.facing==Facing.RIGHT) {
        this.facing=Facing.UP;
      }
    } else {
      if(this.facing==Facing.UP){
        this.facing=Facing.RIGHT;
      } else if (this.facing==Facing.RIGHT) {
        this.facing=Facing.DOWN;
      } else if (this.facing==Facing.DOWN) {
        this.facing=Facing.LEFT;
      } else if (this.facing==Facing.LEFT) {
        this.facing=Facing.UP;
      }
    }
  }

  public void show() {
    pushMatrix();
    fill(c);
    rectMode(CENTER);
    translate(0.5f*normal.x, 0.5f*normal.y, 0.5f*normal.z);
    if (abs(normal.x) > 0) {
      rotateY(HALF_PI);
    } else if (abs(normal.y) > 0) {
      rotateX(HALF_PI);
    }
    square(0, 0, 1);
    this.display.show();
    popMatrix();
  }
}
enum Facing {
  UP,
  DOWN,
  LEFT,
  RIGHT,
  FRONT,
  BACK
}
class IdDisplay {
    int id;

    public IdDisplay(int id) {
        this.id = id;
    }

    public void show() {
        fill(0);
        scale(0.02f);
        text(id, 0 , 0 , 1 );
        scale(1, -1);
        text(id, 0 , 0 , -1 );
        scale(1, -1);
    }
}
public void keyPressed () {
  if (!move.animate) {
    if(key == 'm' || key == 'M' || key == 'w' || key == 'W') {
      println("if you want the ai solve this move is illegal");
      DoStuff(key);
    } else {
      DoStuff(key);
    }
  }
}
public void DoStuff(char keys) {
  if (!move.animate) {
    switch (keys) {
    case ' ' :
      cube.shuffleCube();
      break;
    case 's' :
      //start solving the cube
      cube.solving = true;
      break;
    case 'y' :
      cube.doPerm(algorithm.getAlgorithm("yperm"));
      break;
    case 't' :
      cube.doPerm(algorithm.getAlgorithm("tperm"));
      break;
    case 'j' :
      cube.doPerm(algorithm.getAlgorithm("jperm"));
      break;
   case 'p' :
      cube.doPerm(algorithm.getAlgorithm("lperm"));
      break;
    case 'm' :
      move = new Move(2, 0, 0, 1, cube.getCube());
      move.start();
      break;
    case 'M' :
      move = new Move(2, 0, 0, -1, cube.getCube());
      move.start();
      break;
    case 'w' :
      move = new Move(0, -2, 0, 1, cube.getCube());
      move.start();
      break;
    case 'W' :
      move = new Move(0, 2, 0, -1, cube.getCube());
      move.start();
      break;
    case 'l' :
      move = new Move(-1, 0, 0, -1, cube.getCube());
      move.start();
      break;
    case 'L' :
      move = new Move(-1, 0, 0, 1, cube.getCube());
      move.start();
      break;
    case 'r' :
      move = new Move(1, 0, 0, 1, cube.getCube());
      move.start();
      break;
    case 'R' :
      move = new Move(1, 0, 0, -1, cube.getCube());
      move.start();
      break;
    case 'f' :
      move = new Move(0, 0, 1, 1, cube.getCube());
      move.start();
      break;
    case 'F' :
      move = new Move(0, 0, 1, -1, cube.getCube());
      move.start();
      break;
    case 'b' :
      move = new Move(0, 0, -1, -1, cube.getCube());
      move.start();
      break;
    case 'B' :
      move = new Move(0, 0, -1, 1, cube.getCube());
      move.start();
      break;
    case 'u' :
      move = new Move(0, -1, 0, -1, cube.getCube());
      move.start();
      break;
    case 'U' :
      move = new Move(0, -1, 0, 1, cube.getCube());
      move.start();
      break;
    case 'd' :
      move = new Move(0, 1, 0, 1, cube.getCube());
      move.start();
      break;
    case 'D' :
      move = new Move(0, 1, 0, -1, cube.getCube());
      move.start();
      break;
    }
  }
}
class Move {
  float angle = 0;
  int x = 0;
  int y = 0;
  int z = 0;
  int direction;
  boolean animate = false;
  Cube cube;

  Move(int x, int y, int z, int direction, Cube cube) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.direction = direction;
    this.cube = cube;
  }
  public void start() {
    this.animate = true;
  }
  public void update() {
    if (this.animate) {
      this.angle += direction * 0.3f; //animacioval
      //this.angle=HALF_PI*direction; //animvacio nelkul
      if (abs(this.angle) >= HALF_PI) {
        this.angle = 0;
        this.animate = false;
        if (abs(z)==1) {
          cube.turnZ(z, direction);
        } else if(abs(z)==2) {
          cube.turnZ(0, direction);
        }else if (abs(x)==1) {
          cube.turnX(x, direction);
        }else if(abs(x)==2) { // middle
          cube.turnX(0, direction);
        }else if (abs(y)==1) {
          cube.turnY(y, direction);
        }else if(abs(y)==2) {
          cube.turnY(0, direction);
        }
      }
    }
  }
}
public class OldPochman {
    Cube cube;
    int buffer;
    String moveList;
    private JSONObject json;
    private ArrayList<OldPochmanAlgorithm> algorithms = new ArrayList<OldPochmanAlgorithm>();


    public OldPochman (Cube cube, String moveList) {
        this.cube = cube;
        this.buffer = lookForEdgeBuffer();
        this.moveList = moveList;

        json = loadJSONObject("pochmanTargetPosition.json");
        for (String key : (String[]) json.keys().toArray(new String[json.size()])) {
            // Get the JSON array associated with the key
            JSONArray array = json.getJSONArray(key);

            // Convert the JSON array to a String array
            String[] moves = new String[array.getJSONArray(0).size()];
            for (int i = 0; i < array.getJSONArray(0).size(); i++) {
                moves[i] = array.getJSONArray(0).getString(i);
            }
            String algorithm = array.getString(1);

            // Create a new Algorithm object and add it to the list
            algorithms.add(new OldPochmanAlgorithm(key, moves, algorithm));
        }
    }

    public void printAlgorithms() {
        for (OldPochmanAlgorithm algorithm : algorithms) {
            println(algorithm.getName() + " " + join(algorithm.getSetup(), " ") + " " + algorithm.getAlgorithm());
        }
    }

    public int lookForEdgeBuffer() {
        for (Cubie cubie : cube.data) {
            if(cubie.x == 1 && cubie.y == -1 && cubie.z == 0) {
                for (Face face : cubie.faces) {
                  if(face.facing == Facing.UP) {
                    return face.id;
                  }
                }
            }
        }
        return 1;
    }

    public int lookForCornerBuffer() {
        for (Cubie cubie : cube.data) {
            if(cubie.x == -1 && cubie.y == -1 && cubie.z == -1) {
                for (Face face : cubie.faces) {
                  if(face.facing == Facing.UP) {
                    return face.id;
                  }
                }
            }
        }
        return 1;
    }

    public boolean isItInAlgorithms(String id) {
        for (OldPochmanAlgorithm algorithm : algorithms) {
            if (algorithm.getName().equals(id)) {
                return true;
            }
        }
        return false;
    }

    public OldPochmanAlgorithm moveToTarget(int id) {
       OldPochmanAlgorithm algo = null;
        for (OldPochmanAlgorithm algorithm : algorithms) {
            if (algorithm.getName().equals(Integer.toString(id))) {
                algo = algorithm;
            }
        }
        return algo;
    }
}
public class OldPochmanAlgorithm {
    private String name;
    private String[] setup;
    private String algorithm;

    public OldPochmanAlgorithm(String name, String[] setup, String algorithm) {
        this.name = name;
        this.setup = setup;
        this.algorithm = algorithm;
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name
    public void setName(String name) {
        this.name = name;
    }

    // Getter for setup
    public String[] getSetup() {
        return setup;
    }

    // Setter for setup
    public void setSetup(String[] setup) {
        this.setup = setup;
    }

    // Getter for algorithm
    public String getAlgorithm() {
        return algorithm;
    }

    // Setter for algorithm
    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("OldPochmanAlgorithm{name='").append(name).append('\'');
        sb.append(", setup=").append(setup.toString());
        sb.append(", algorithm='").append(algorithm).append('\'');
        sb.append('}');
        return sb.toString();
    }
}
public class RubiksCubeLogic  {
    private String moveList = "";
    boolean solving = false;
    private Cube cube;
    private AlgorithmCollection algorithmCollection = new AlgorithmCollection();
    OldPochman op;
    int animationTimer = 0;
    int moveCounter = 0;
    private boolean edgesSolved = false;
    boolean isParityNeeded = true;

    public RubiksCubeLogic() {
        this.cube = new Cube();
        this.op = new OldPochman(this.cube, this.moveList);
    }

    public Cube getCube() {
        return this.cube;
    }

    public void shuffleCube() {
        int rand = round(random(10, 20));
        println("Shuffle is "+ rand + " moves long.");
        char[] moves = {'l','L','r','R','u','U','d','D','f','F','b','B'};
        for (int i = 0; i < rand; i++) {
            int random = round(random(0, 11));
            moveList += moves[random];
        }
    }

    public void doPerm(Algorithm alg) {
        for (int i = 0; i < alg.getMoves().length; i++) {
            this.moveList += alg.getMoves()[i];
        }
    }

    private String reverseAlgorithm(String[] inputs) {
        String[] strings = new String[inputs.length];
        for (int i = 0; i < inputs.length; ++i) {
            strings[i] = inputs[i];
        }
        for (int i = 0; i < strings.length / 2; i++) {
            String temp = strings[i];
            strings[i] = strings[strings.length - 1 - i];
            strings[strings.length - 1 - i] = temp;
        }
        StringBuilder sb = new StringBuilder();
        for (String s : strings) {
            char c = s.charAt(0);
            if (Character.isUpperCase(c)) {
                sb.append(Character.toLowerCase(c));
            } else if (Character.isLowerCase(c)) {
                sb.append(Character.toUpperCase(c));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    public void solve() {
        this.solving = true;
        if (this.edgesSolved) {
            if(moveCounter%2==1 && isParityNeeded){
                this.moveList += "ruRFruuRuuRfruruuRU";
                isParityNeeded = false;
            }
            int id = this.op.lookForCornerBuffer();
            if (id != 3 && id != 5 && id != 0) {
                SolveOnePiece(id);
                //this.solving = false;  //minden lepes utan megallas
            } else {
                ArrayList<Cubie> notInPosition = this.cube.checkIfAllCornersAreSolved();
                if (notInPosition.size() > 0) {
                    this.animationTimer++;
                } else {
                    this.animationTimer = 0;
                    println("corners are done, it took " + Integer.toString(moveCounter) + " moves.");
                    this.solving = false;
                }
                if(this.animationTimer >= 100) {
                    this.animationTimer = 0;
                    println("corners are not done, breaking the plugging.");
                    boolean chekForFlippedBuffer = breakPlugging(notInPosition.get(0));
                    if(!chekForFlippedBuffer) {
                        breakPlugging(notInPosition.get(1));
                    }

                }
            }
        } else {
            int id = this.op.lookForEdgeBuffer();
            if (id != 117 && id != 118) {
                SolveOnePiece(id);
                //this.solving = false;  //minden lepes utan megallas
            } else {
                ArrayList<Cubie> notInPosition = this.cube.checkIfAllEdgesAreSolved();
                if (notInPosition.size() > 0) {
                    this.animationTimer++;
                } else {
                    println("edges are done, it took " + Integer.toString(moveCounter) + " moves.");
                    this.edgesSolved = true;
                    this.animationTimer = 0;
                }
                if(this.animationTimer >= 100) {
                    println("edges are not done, breaking the plugging.");
                    boolean chekForFlippedBuffer = breakPlugging(notInPosition.get(0));
                    if(!chekForFlippedBuffer) {
                        breakPlugging(notInPosition.get(1));
                    }
                    this.animationTimer = 0;
                }
            }
        }
    }

    public boolean breakPlugging(Cubie cubie) {
        for (Face face : cubie.faces) {
            if(this.op.isItInAlgorithms(Integer.toString(face.id))) {
                // this is needed becouse the buffer can get stuck
                if (face.id == 117 || face.id == 118 || face.id == 3 || face.id == 5 || face.id == 0) {
                    return false;
                }
                println(face.id);
                println("solve");
                SolveOnePiece(face.id);
                return true;
            }
        }
        return false;
    }

    public void SolveOnePiece(int id) {
        this.moveCounter++;
        OldPochmanAlgorithm algo = this.op.moveToTarget(id);
        this.moveList += join(algo.getSetup(),"");
        this.moveList += join(algorithmCollection.getAlgorithm(algo.getAlgorithm()).getMoves(), "");
        try {
            Thread.sleep(100);
        } catch(Exception e) {
            println(e);
        }
        String reversedMoves = reverseAlgorithm(algo.getSetup());
        logMove(Integer.toString(id), join(algo.getSetup(),""), algorithmCollection.getAlgorithm(algo.getAlgorithm()).getName(), reversedMoves);
        this.moveList += reversedMoves;
    }

    private void logMove(String id, String setup, String algorithm, String redo) {
        println("buffer id: " + id + " || setup: " + setup + " || algorithm: " + algorithm + " || redo setup: " + redo);
    }

}
class Settings {
  public int dimension = 3;
  public int sideLength = 50;
  public int cameraZoomIn = 500;
  public int backgroundColor = 200;
  public float cubeOffstet = (dimension - 1) * sideLength * 0.5f;

  // cube base settings
  public int boxColor = 255; //fehér
  public int strokeColor = 0; //fekete
  public float strokeWeight= 0.1f; //fekete

  // color settings
  public int blue = color(0,0,255);
  public int green = color(0,255,0);
  public int white = color(255,255,255);
  public int yellow = color(255,255,0);
  public int orange = color(255,150,0);
  public int red = color(255,0,0);
}


  public void settings() { size(600, 600, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
